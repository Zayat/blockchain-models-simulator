#!/usr/bin/env python
# -*- mode: python; coding: utf-8; fill-column: 80; -*-

from bcns.events import Events as events

from .stats import Tracker

# Genesis block miner ID.
Genesis_Miner_ID = -1


class Miner(object):
    __slots__ = (
        'id',                       # Miner ID (uniquely identifies a miner)
        'hashing_power',            # Hashing power
        'chain',                    # Chain of blocks (maintained by each miner)
        'block_count',              # Number of blocks mined
        'next_block_time',          # Time at which next block will be mined by the miner
        'generated_blocks',         # List of blocks generated by the miner
        'received_blocks',          # List of blocks received by the miner
        'orphaned_blocks',          # List of orphaned blocks (i.e., blocks lost after discovering a longer chain)
        'own_orphaned_blocks',      # List of orphaned blocks (i.e., blocks lost after discovering a longer chain)
        '_orphan_stats',            # Simple statistics on orphaned blocks
        '_own_orphan_stats',        # Simple statistics on own orphaned blocks
        'last_block_arrival_time',  # Time of starting the next block mining
        'wasted_time',              # Time wasted (or lost work) beyond the block orphaning
        'stale_wasted_time',        # Time wasted (or lost work) while mining on stale block (other block was announced)
        'outstanding_blocks',
        'next_legit_hash',
    )

    def __init__(self, id, hashing_power, chain):
        self.id = id
        self.hashing_power = hashing_power
        self.chain = chain
        self.block_count = 0
        self.next_block_time = -1
        self.last_block_arrival_time = 0
        self.generated_blocks = []
        self.received_blocks = []
        self.orphaned_blocks = []
        self.own_orphaned_blocks = []
        self._orphan_stats = Tracker()
        self._own_orphan_stats = Tracker()
        self.wasted_time = Tracker()
        self.stale_wasted_time = Tracker()
        self.outstanding_blocks = False
        self.next_legit_hash = -1


    def orphan_this_block(self, block):
        self._orphan_stats.update(1)
        self.orphaned_blocks.append(block)
        self._own_orphan_stats.update(1)
        self.own_orphaned_blocks.append(block)

    def _add_own_block(self, block, curr_time):
        """Add own block to chain."""
        self.chain.add_last_block(block)
        self.block_count += 1
        self.generated_blocks.append(block)
        self.last_block_arrival_time = curr_time
        return events.ANNOUNCE_NEW_BLOCK

    def _add_other_block(self, block, curr_time, coordinator=False):
        """Add a block mined by others to chain."""
        # TODO Fix wasted_time time
        self.wasted_time.update(curr_time - self.last_block_arrival_time)
        # TODO Fix stale_wasted_time time
        self.stale_wasted_time.update(curr_time - block.timestamp)

        new_blocks, depth, parent = self.chain.get_non_common_suffix(block)
        # Number of blocks that have been orphaned.
        num_orphaned = self.chain.length - parent.height
        # if force:
        #     print("[BEFORE] " + str(self))
        #     print("[TEST] forced chain switch: "
        #           + " \n\t new blocks:" + str([str(b.hash) for b in new_blocks])
        #           + " \n\t parent: " + str(parent)
        #           + " \n\t num_orphaned: " + str(num_orphaned))
        if coordinator and num_orphaned > 0:
            return events.NEW_BLOCK_IGNORED

        if num_orphaned > 0:
            self._orphan_stats.update(num_orphaned)
            self.orphaned_blocks.append(
                self.chain.blocks[self.chain.length - num_orphaned:])
            own_orphans = [ b for b in
                self.chain.blocks[self.chain.length - num_orphaned:] if b.miner.id is self.id]
            self.own_orphaned_blocks.append(own_orphans)
            self._own_orphan_stats.update(len(own_orphans))
        # TODO: performance bottleneck at replace_blocks

        self.chain.replace_blocks(new_blocks, parent)
        self.last_block_arrival_time = curr_time
        #if force:
        #    print("[After] " + str(self))
        return events.NEW_BLOCK_ADDED

    def add_block(self, block, current_time, coordinated=False):
        #assert (len(self.chain.blocks) == self.chain.blocks[-1].height)
        if coordinated: ##force changes
            if block.miner.id == self.id : #I am the miner of this block
                if block.previous == self.chain.blocks[-1] and not self.outstanding_blocks and block.hash == self.next_legit_hash: #This block builds on top of my current chain (not a stale timer) and This is the first block I find in this round
                    self.outstanding_blocks = True
                    return self._add_own_block(block, current_time)
                if block ==  self.chain.blocks[-1]: #This is the block I just found, and the coordinator is acknowledging it
                    self.outstanding_blocks = False
                    return events.NEW_BLOCK_ADDED
                if self.outstanding_blocks and block.hash == self.next_legit_hash: #I already found a block and I am waiting for an ACK, this is purely wasted work
                    self.block_count += 1
                    self.generated_blocks.append(block)
                    self.orphan_this_block([block])
                    if  block.hash == self.next_legit_hash:
                        return events.NEW_BLOCK_WASTED
                    else:
                        return events.NEW_BLOCK_IGNORED

            # TODO: Performance bottleneck at miner._add_other_block and chain.replace_blocks
            if block.miner.id != self.id: # I am a coordinator or the coordinator forwarded me this block
                if self.hashing_power > 0:
                    self.outstanding_blocks = False
                    return self._add_other_block(block, current_time, coordinator=False)
                else:
                    return self._add_other_block(block, current_time, coordinator=True)
        else: #p2p
            if block.miner.id == self.id and block.height > self.chain.length:
                return self._add_own_block(block, current_time)
            if block.height > len(self.chain.blocks):
                return self._add_other_block(block, current_time)

        return events.NEW_BLOCK_IGNORED

    @property
    def orphan_stats(self):
        return self._orphan_stats

    @property
    def own_orphan_stats(self):
        return self._own_orphan_stats

    def short_str(self):
        return ("Miner{id: %d, hp: %.2f}" % (self.id, self.hashing_power))

    def __eq__(self, other):
        return self.id == other.id

    def __lt__(self, other):
        return self.id < other.id


    def __str__(self):
        return ("Miner{id: %d, hp: %.2f, #blks: %d, #orphans: %d, chain: %s}" %
                (self.id, self.hashing_power, self.block_count,
                 self._orphan_stats.csum, self.chain))
